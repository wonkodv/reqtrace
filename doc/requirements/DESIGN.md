# Design


## Requirements

Requirement Objects are dumb containers containing the data of one Requirement

### DSG_REQ_FIELDS: Requirement Fields

Attributes of a requirement that this tool requires:
*   ID: a short string that uniquely identifies this requirement

Optional Attributes that are handled:
*   Title:  Text that briefly summarizes this requirement (on line)
*   Description: Text that gives detailed description
*   Coverage: List of requirement IDs that are covered by this one
*   Dependencies: List of requirement IDs which cover this one
*   Tags:   List of Strings that can be used to categorize requirements
*   Delegates: List of requirements in the same artefact that can be covered instead of this one

Attributes inferred during requirement Parsing:
*   Location:   Artefact that defines this requirement and the location inside
    the artefact where it is defined

Arbitrary Additional Attributes are possible, for example

*   History: Text about how this requirement changed
*   Comment: Text with even more details, further reading, etc. that has a lower
    priority than Description which may be excluded from reports

Covers:
*   REQ_UP
*   REQ_DOWN
*   REQ_DELEGATION


## Artefact                                                      `

An Artefact represents a (group of) files.
They load cached requirements or parse
them as needed.

### DSG_ART_FILES: An artefact loads one or more Files

An Artefact represents one or more files of the same type.

Covers:
*   ARCH_ARTEFACT


### DSG_ART_PARSE: Artefact Parsing

On demand, the Artefact parses the requirements in the files it represents.
The artefact stores the (untraced) requirements and all parsing errors

Covers:
*   ARCH_ARTEFACT
*   REQ_LATE_ERRORS


### DSG_ART_CONFIG: Artefact Configuration Fields

*   ID
*   paths:  List of Paths or pattern with which to find the files
*   parser:   id of a parsing strategy, e.g. `Markdown Requirements`, `Rust
    Coverage Marks`, `JSON`
*   parser arguments: Object that is passed to the parser
*   caching: boolean, whether to cache or parse on every access

Covers:
*   ARCH_ARTEFACT

### DSG_ART_IGNORE_DERIVED: Ignore Derived Requirements

Artefacts can be configured to ignore derived requirements


## Formats

### Data Format Considerations

The data format for internal Caching, data exchange, and machine readable output
needs to be well supported, text based and produce a reasonably small diff if
little changed.

Candidates:
*   Machine Readable
    *   JSON
    *   YAML
    *   TOML
    *   CBOR
*   Human readable
    *   Markdown
    *   Tex
    *   HTML
    *   Typst
    *   (JSON, YAML)
    *   TOML

Text based formats will work better with SVCS, debugging and plumbing in other tools with limited libraries e.g. Bash scripts.
For the machine readable format, JSON is chosen. The possible benefits of other formats (easier to write for humans, smaller size, more data types) are not
needed to represent tracing information.
For human readability, Markdown is the most readable format. Other formats might be more useful for further processing with tools, but that can be achived by
generating them from the json export.

For configuration files, JSON is not comfortable enough to maintain, YAML is too complex, so TOML is chosen.

#### DSG_JSON_IMPORT: JSON for Importing Requirements

Artefacts which can not be parsed by the tool are generated by other tools and imported via JSON

Covers: REQ_VCS, REQ_EXTENSIBLE

Depends: FMT_JSON

#### DSG_JSON_EXPORT: JSON for Exporting Results

Errors, Requirements, Status, Tracing Info can be exported as JSON

Covers: REQ_VCS, REQ_MACHINE_READABLE

Depends: FMT_JSON

#### DSG_EXPORT_FORMAT_MARKDOWN: Export to Markdown

Errors, Requirements, Status, Tracing Info can be exported as a useful
standalone Markdown File

Covers: REQ_VCS, REQ_HUMAN_READABLE

### DSG_CONFIG_TOML: Use a Single TOML File as Configuration

The configuration should be placed in one file `requirements.toml`.
The format is TOML.
The structure of the Configuration is detailed in the Manual

Covers:
*   REQ_CONFIG: Simple Configuration in One File

## Command Line Interface


### DSG_CLI: Offer a simple Command Line Interface

The tool should be invoked via a simple CLI and set the exit code to indicate if a job was successful.

Covers:
*   REQ_MACHINE_FRIENDLY: Easy to include in automated work flows

### DSG_CLI_RETURN_CODE: Set return Code to indicate success

Set the process' return code to:
*   `2` if there were fatal errors (invalid configuration or similar)
*   `1` if there were errors (file not found, parser errors, uncovered requirement, derived
    requirement, ...)
*   `0` otherwise

Covers:
*   REQ_MACHINE_FRIENDLY: Easy to include in automated work flows
*   UC_CHECK: Check for correct Tracing


### DSG_JOBS: Jobs control what operations to perform

One or more Jobs can be configured. Each Job specifies an operation to perform, the format that results
should be presented in and the file to store results in.

### DSG_JOB_PARSE: Parse all Artefacts

Parse the Artefacts

Covers: UC_PARSE

### DSG_JOB_PARSE_SOME: Parse a set of Artefacts

Parse one or more Artefacts to make finding errors easier.

Covers: UC_PARSE

### DSG_JOB_TRACE: Trace Requirements

Trace Requirements

Covers: UC_TRACE

### DSG_JOB_FORMAT: Specify Format of Reports

Specify the Format that results are presented in

Covers:
*   REQ_FORMATS: Well defined Formats

### DSG_JOB_FILE: Specify File to Store Reports in

Specify the file that results are stored in, treating `-` as the stdout channel.

#### DSG_JOB_RETURN_CODE: Return Code Indicates if Tracing is Correct

It can be specified for each job, if the return code should be set or not,
allowing for example, to update the tmx without indicating an error if the tracing is not
perfect yet.

## DSG_TRACING_GRPAH: Tracing Graph

The Class `Graph` holds a graph of `Artefact` objects as
given by the Configuration.
It computes which `Requirement`s are covered.

Covers:
*   ARCH_TRACING_GRAPH

### DSG_TG_FORK: Trace Edge Groups

The Graph of artefacts has the following properties:

*   Nodes in the graph are:
    * Forks
    * Artefacts
*   Edges in the Graph have a direction.
*   Edges always connect an Artefact to a Fork

As example, in this project, `DSG` Requirements from `DESIGN.md` are
covered either by code, or by `FMT` Requirements from `FORMATS.md`.
Code an `FORMATS.md` both have an edge to the same Fork below
`DESIGN.md`.
Each Design also has to be covered by a unit test, so unit tests are
below a separate fork below `DESIGN.md`

Covers:
*   ARCH_TRACING_GRAPH

### DSG_TG_VAL_NO_LOOP: Validate that the Graph has no Loops

After assembling of the graph, if a loop can be found in the graph of artefacts, an error is emitted.
This prevents further tracing.

Covers:
*   ARCH_TRACING_GRAPH
### DSG_TG_VALIDATE_EDGE: Validate Edge is used at least once

After tracing, if an edge can be found, along which no requirement is
covered, an error is emitted. This is likely a misconfiguration.

Covers:
*   ARCH_TRACING_GRAPH

#### DSG_TRACE_UPWARDS: Trace upwards using Covers attribute

Requirement U covers Requirement D if U.id appears in D.Covers and
D.Artefact directly traces against U.Artefact

Covers:
*   REQ_TRACE
*   REQ_MATCH_ID
*   REQ_UP
*   ARCH_TRACING_GRAPH

#### DSG_TRACE_DOWNWARDS: Trace downwards using Depends attribute

Requirement U covers Requirement D if D.id appears in U.Depends and
D.Artefact directly traces against U.Artefact

Covers:
*   REQ_TRACE
*   REQ_MATCH_ID
*   REQ_DOWN
*   ARCH_TRACING_GRAPH

#### DSG_TRACE_DERIVED: Record requirements that do not cover anything

Requirement R is derived if there is no Requirement U so that R covers U.

Covers:
*   REQ_TRACE
*   ARCH_TRACING_GRAPH



#### DSG_TRACE_UNCOVERED: Record requirements that are not completely covered

Record Requirement R as Uncovered along Fork F if there is no
Requirement D which covers R, where R is from the Artefact above F and
D is from one of the artefacts below D.

For example in this Project, a DSG Requirement is covered if it is
covered by a unittest AND (it is covered by Code OR it is covered by
a FMT requirement).

Covers:
*   REQ_TRACE
*   ARCH_TRACING_GRAPH

#### DSG_TRACE_TRACE_TITLE: When tracing upwards or downwards match title

When tracing Upwards or Downwards, emit an error if the title of the coverage does
not match the title of the covered requirement

Example:
    ### REQ_U: Title of Upper

    An Upper Requirement

    ### REQ_D: Title of Lower

    A Lower Requirement that covers REQ_U with an exactly mathcing title.

    Covers:
    *   REQ_U: Title of Upper

Covers:
*   REQ_TRACE
*   REQ_VAL_TITLE: Check matching title
*   ARCH_TRACING_GRAPH


#### DSG_TRACE_DEPENDS_EXIST: Depend Links must exist

For every Link L in  U.Depends of a Requirement U,
there must exist a Requirement D with with D.Id == L.id and 
D.Artefact traces against U.Artefact

Covers:
*   REQ_TRACE
*   REQ_DOWN
*   ARCH_TRACING_GRAPH

#### DSG_TRACE_COVERS_EXIST: Cover Links must exist

For every Link L in  D.Depends of a Requirement D,
there must exist a Requirement U with with U.Id == L.id and 
D.Artefact traces against U.Artefact

*   REQ_TRACE
*   REQ_DOWN
*   ARCH_TRACING_GRAPH
