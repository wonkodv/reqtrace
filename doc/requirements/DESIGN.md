# Design


## Requirements

Requirement Objects are dumb data containers for one Requirement

### DSG_REQ_FIELDS: Requirement Fields

Attributes of a requirement that this tool requires:
*   ID: a short string that uniquely identifies this requirement

Optional Attributes that are handled:
*   Title:  Text that briefly summarizes this requirement (on line)
*   Description: Text that gives detailed description
*   Coverage: List of requirement IDs that are covered by this one
*   Dependencies: List of requirement IDs which cover this one
*   Tags:   List of Strings that can be used to categorize requirements

Attributes inferred during requirement Parsing:
*   Location:   Artefact that defines this requirement and the location inside
    the artefact where it is defined

Arbitrary Additional Attributes are possible, for example

*   History: Text about how this requirement changed
*   Comment: Text with even more details, further reading, etc. that has a lower
    priority than Description which may be excluded from reports

Covers:
*   REQ_UP
*   REQ_DOWN
*   REQ_DELEGATION


## Artefacts

Artefacts represent a (group of) files. They load cached requirements or parse
them as needed.


### DSG_ART_PARSE: Artefact Parsing

Artefact parses the requirements in the files it represents.

### DSG_ART_CACHING: Cache Parsing Results

Artefact manages a cache of already parsed requirements and only 

Covers:
*   REQ_FAST

### DSG_ART_EXTERNAL_PARSER: External Artefact Parser

If files can not be parsed by this tool, an external program is invoked which
writes  the requirements into a temporary file or to its `stdout` stream in the
JSON format, or as Text which is then processed by the regex parsers.

TODO: think about filenames, locations, regexparser, how to configure it and so on.



References:
*   FMT_JSON
*   FMT_JSON_REQUIREMENT

### DSG_ART_CONFIG: Artefact Configuration Fields

*   ID
*   paths:  List of Paths or pattern with which to find the files
*   parser:   id of a parsing strategy, e.g. `Markdown Requirements`, `Rust
    Coverage Marks`, `External`
*   parser arguments: Object that is passed to the parser
*   caching: boolean, whether to cache or parse on every access


## Formats

### Data Format Considerations

The data format for internal Caching, data exchange, and machine readable output
needs to be well supported, text based and produce a reasonably small diff if
little changed.

Candidates:
*   JSON
*   ?

for smaller diff, all lists should be sorted 


### Computing effort Considerations

Depending on the artefact type, parsing an artefact may not be slower than
retrieving the information from a cache, but it may also be a lot slower, if the
artefact format is complicated (large pdf) and the cache format good.

To minimize the computing effort for accessing the cache, the following datasets
are stored in a file each:
*   Requirements parsed from one artefact
*   Coverage Links from one artefact to another

To prevent over caching a fingerprint of the Artefact is stored in the cached
requirements, and the fingerprint of all related artefacts is stored with the
coverage links.

#### DSG_JSON_CACHE: JSON for Storing State

JSON is used to store parsing results and computed coverage

Covers: REQ_VCS, REQ_FAST

Depends: FMT_JSON

#### DSG_JSON_CACHE_SORT: JSON Cache sorted

Sort lists, smaller diff

#### DSG_JSON_IMPORT: JSON for Importing Requirements

Artefacts which can not be parsed by the tool are generated by other tools and imported via JSON

Covers: REQ_VCS, REQ_EXTENSIBLE

Depends: FMT_JSON

#### DSG_JSON_EXPORT: JSON for Exporting Results

Tracing results can be exported as json

Covers: REQ_VCS, REQ_MACHINE_READABLE

Depends: FMT_JSON

#### DSG_FINGERPRINT_ART: Fingerprint of Artefacts

The Cache of an artefact is checked for up-to-dateness with a fingerprint.

The fingerprint of an artefact is computed as hash over:
*   version of the tool
*   parsing-type of the artefact
*   for all files that make up an Artefact:
    *   The sha256 of the file if it is small
    *   The modification time and size if it is large


Covers:
*   REQ_NO_OVERCACHING

Comment:
Since the version is included in the fingerprint, the details can be changed
easily.

#### DSG_FINGERPRINT_TRACING: Fingerprint of Tracing

The Cache of an artefact is checked for up-to-dateness with a fingerprint.

The fingerprint of a tracing is computed as hash over:
*   version of the tool
*   The tracing graph
*   The fingerprint of the artefacts


### Export Formats

Exporting data is kept as simple as possible by behaving like a good unix tool.
Results are printed on stdio, errors are printed on stderr.
The format can be chosen in config or on the command line.

#### DSG_EXPORT_DATA: Export data to stdout

Print results to stdout in a chosen format

#### DSG_EXPORT_ERRORS: Export errors to stderr

Print Errors to stdout in a chosen format

#### DSG_EXPORT_FORMAT: Allow Selecting the Export Format

The format in which errors and results are written to the out streams can be
chosen.



#### DSG_EXPORT_FORMAT_JSON: Export to JSON

Errors, Requirements, Status, Tracing Info can be exported as JSON

#### DSG_EXPORT_FORMAT_MARKDOWN: Export to Markdown

Errors, Requirements, Status, Tracing Info can be exported as a useful
standalone Markdown File

#### DSG_EXPORT_FORMAT_TEX: Export to TEX

Errors, Requirements, Status, Tracing Info can be exported as tex macro calls,
do that the output can be used via `\include{}` in a tex project that defines
the relevant macros.

Tag:
*   TODO

Todo:
*   Define the exact format of each object


### DSG_CONFIG_TOML: Use a Single TOML File as Configuration

The configuration should be placed in one file `requirements.toml`.
The format is TOML.
The structure of the Configuration is detailed in the Manual

Covers:
*   REQ_CONFIG: Simple Configuration in One File

Requires:
*   MAN_CONFIG_STRUCTURE: Configuration Structure and Fields

## Tracing Algorithm

#### DSG_TRACE_UPWARDS: Trace upwards using Covers attribute

Requirement U covers Requirement D if U.id appears in D.Covers and
D.Artefact directly traces against U.Artefact

Covers: REQ_TRACE, REQ_MATCH_ID, REQ_UP

#### DSG_TRACE_DOWNWARDS: Trace downwards using Depends attribute

Requirement U covers Requirement D if D.id appears in U.Depends and
D.Artefact directly traces against U.Artefact

Covers: REQ_TRACE, REQ_MATCH_ID, REQ_DOWN

#### DSG_TRACE_DELEGATION: Trace Requirements inside same Artefact

A Requirement can delegate to a requirement in the same artefact, so that itself
does not need to be covered.

Requirement U covers Requirement D if D.id appears in U.Depends and
D.Artefact directly traces against U.Artefact.

Covers: REQ_TRACE, REQ_MATCH_ID, REQ_DELEGATION

#### DSG_TRACE_DERIVED: Mark requirements that do not cover anything

Requirement R is derived if there is no Requirement U so that R covers U.

Covers: REQ_TRACE

#### DSG_TRACE_UNCOVERED: Mark requirements that are not covered

Requirement R is uncovered if there is no Requirement D so that D covers R.


Covers: REQ_TRACE
#### DSG_TRACE_TRACE_TITLE: When tracing upwards or downwards match title

When tracing Upwards or Downwards, emit an error if the title of the coverage does
not match the title of the covered requirement

Example:
    ### REQ_U: Title of Upper

    An Upper Requirement

    ### REQ_D: Title of Lower

    A Lower Requirement that covers REQ_U with an exactly mathcing title.

    Covers:
    *   REQ_U: Title of Upper

Covers:
*   REQ_TRACE
*   REQ_VAL_TITLE: Check matching title


#### DSG_TRACE_DEPENDS_EXIST: Depend Links must exist

For every Link L in  U.Depends of a Requirement U,
there must exist a Requirement D with with D.Id == L.id and 
D.Artefact traces against U.Artefact

Covers: REQ_TRACE, REQ_DOWN
#### DSG_TRACE_COVERS_EXIST: Cover Links must exist

For every Link L in  D.Depends of a Requirement D,
there must exist a Requirement U with with U.Id == L.id and 
D.Artefact traces against U.Artefact

Covers: REQ_TRACE, REQ_UP
