
# Config File


Json File

*   Artefacts
    *   id
        *   paths
        *   parser
*   tracing
    *   list of:
        *   pair of
            *   list of upwards Requirements
            *   List of downards Requirements


# Artefact Formats

The set of formats that are passed by this tool are well defined by this
specification.


## Tool wide Formats

These Rules hold for all Artefact formats supported by the tool except JSON,
where anything is possible.

### FMT_ID: Requirement Identifier

Requirement identifier consist of letters, digits and underscore, specifically
they match the Regular Expression

    [A-Za-z][a-zA-Z0-9_]+[a-zA-Z0-9]

This way they are safe for use in filenames, URLs, markdown, code, allow
partitioning and are double click friendly.

Covers:
*   REQ_FORMATS (Well defined Formats)

Comment:
Discussion in the [README](README.md#requirement-ids)

## Markdown Requirements

This project's preferred format as used in `REQUIREMENTS.md` or this File.

### FMT_MD: Markdown File Format


The artefact is a Markdown file with freely chosen layout.  A Requirement is in
a heading line with requirement ID and title, followed by description and other
attributes.

Covers:
*   REQ_FORMATS: Well defined Formats

Depends:
*   FMT_MD_START
*   FMT_MD_DESC
*   FMT_MD_DESC_HEADINGS
*   FMT_MD_ATTRIBUTES


### FMT_MD_START: Requirement Start

A Requirement starts with a `#` heading of any level that has the form `ID:
TITLE`.

### FMT_MD_DESC: Description

The paragraphs following the start of the requirement make up the description of
the requirement.

All paragraphs add to the description until:
*   The Start of another Requirement.
*   The start of an Attribute Paragraph
*   A Heading the same level or less. This ends the Requirement.



### FMT_MD_DESC_HEADINGS: Heading Level in Description is adjusted

Headings with a lower level than the starting one, that do not start a nested
requirement are added to the description. Their heading level is adjusted by
removing as many leading `#` as the requirement had

### FMT_MD_ATTRIBUTES: Attributes

Attributes are parsed from paragraphs that start with a single word followed by
a colon. Once the first Attribute Paragraph is encountered, the Parser will add
to the Attribute Value until:

*   The Start of another Requirement.
*   The start of another Attribute Paragraph
*   A Heading the same level or less. This ends the Requirement.

There are 3 types of Attribute Paragraphs:
*   Text: can span multiple Paragraphs
*   Short List: Comma separated list of IDs
*   Long list:  one paragraph that only consists of bullet points

The Attribute `Tags` can be a short or long list of arbitrary Tags which have
the same format as requirement IDs.

The Attributes `Depends` and `Covers` can be short lists of Requirement IDs or
long lists, where each item starts with a requirement id, optionally followed by
a colon and the title of the referenced requirement.

Comment:

    `Covers: Some, IDs,`

or

    `Covers:
    *   Some
    *   IDs

### Example

A Markdown File with the following content:

    # Headline
    ## REQ_ID: Requirement Title
    Description paragraph
    ### Heading in the description
    another Description Paragraph

    Covers: REQ_COV

    ## Headline outside the description

would lead to one Requirement with id `REQ_ID` and title `Requirement Title`
It would cover `REQ_COV` by ID.
The Description would be:

    Description paragraph
    # Heading in the description
    another Description Paragraph


### Markdown Artefact Parsing Options

The following options can be used to configure parsing of markdown artefacts.

#### FMT_MD_OPT_PREFIX: List of Prefixes

A List of strings can be passed, which is used to prevent the parser from
creating unintended requirements from headlines which accidentally have the
right form.

Lines in the markdown file which would start a new requirement, are treated as
normal headings, if the identifier of the would be requirement does not start
with one of the list of prefixes. If the list is empty, no prefix matching is
performed and all matching lines lead to a requirement.


## JSON Requirements

*   [Requirements]
    *   id
    *   location
    *   ...

TODO

## Rust Coverage Marks

Parse `cov_mark::hit!(DSG_001)`

TODO


# Output Formats

## Json
each list sorted to minimize diff !

* Artefacts
  * Unique ID
  * Version Info
  * If File
    * Path
    * Hash over File
  * If Group
    * Child Artefacts (have no upwards or downwards artefact links)
  * Upwards Artefact IDs
  * Downwards Aretefact IDs
  * Requirements defined in that Artefact
    * ID
    * Title
    * Description
    * Location
    * Covers REQ_Id\*
    * Covered-by Req_Id

TODO

## Markdown

With link to artefact.md#req-id

## Latex

Generated by seperate Tool, using latex config, req state. Generates 1 tex file per artefact so recompiling tex is cheaper.
(attention using include or input, one makes aux files the other recompiles from
scratch)

Graph of Artefacts

SubSection per Artefact

SubSubsection per Requirement

ID, Title, \\ref{req-id}

Description

Covers:

* Artefact
  * Completeness [Link]ReqId: Title

Covered By:

* Artefact
  * [Link] ReqId Title

